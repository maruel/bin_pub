#!/usr/bin/env python3
"""
git rb: Rebases all local branches onto their upstreams in topological order
Depends on git squash defined in configs/.config/git/squash.ini
"""

import collections
import os
import platform
import subprocess
import sys
import typing


def run_git_command(
    cmd: typing.List[str], check: bool = True
) -> typing.Tuple[str, int]:
    """Run a git command and return output and return code."""
    result = subprocess.run(cmd, capture_output=True, text=True, check=check)
    return result.stdout.strip(), result.returncode


def get_branch_tree() -> typing.Dict[str, str]:
    """Get all local branches and their upstream relationships."""
    tree = {}
    git_output = run_git_command(["git", "branch", "-l", "--format=%(refname:short)"])
    for branch in sorted(git_output[0].split("\n") if git_output[0] else []):
        if not branch:
            continue
        upstream, rc = run_git_command(
            ["git", "rev-parse", "--abbrev-ref", f"{branch}@{{u}}"], check=False
        )
        if rc == 0 and upstream:
            tree[branch] = upstream
        else:
            print(f"No upstream for {format_branch_name(branch)}")
    return tree


def topo_iter(tree: typing.Dict[str, str]) -> typing.List[typing.Tuple[str, str]]:
    """Perform topological sort on branch dependencies."""
    if not tree:
        return []
    visited: typing.Set[str] = set()
    queue: collections.deque = collections.deque()
    result: typing.List[typing.Tuple[str, str]] = []
    all_branches = set(tree.keys())
    for branch in sorted(all_branches):
        parent = tree[branch]
        if parent not in all_branches:
            queue.append(branch)
    while queue:
        branch = queue.popleft()
        if branch in visited:
            continue
        visited.add(branch)
        result.append((branch, tree[branch]))
        for b in sorted(all_branches):
            if tree[b] == branch and b not in visited:
                queue.append(b)
    return result


def format_branch_name(name: str) -> str:
    """Format branch name with bold ANSI escape codes (disabled on Windows)."""
    if platform.system() == "Windows":
        return name
    return f"\033[1m{name}\033[0m"


def get_tree(ref: str) -> str:
    """Get the tree hash for a reference."""
    return run_git_command(["git", "rev-parse", f"{ref}^{{tree}}"])[0]


def rebase_branch(branch: str, parent: str, start_hash: str) -> bool:
    """Rebase a branch onto its parent."""
    # Check if already up-to-date
    parent_hash, parent_rc = run_git_command(["git", "rev-parse", parent], check=False)
    if parent_rc == 0:
        start_output, start_rc = run_git_command(
            ["git", "rev-parse", start_hash], check=False
        )
        if start_rc == 0 and parent_hash == start_output:
            print(f"- {format_branch_name(branch)}: up-to-date")
            return True
    print(f"- Rebasing: {format_branch_name(branch)}")
    run_git_command(["git", "switch", branch])
    git_output = run_git_command(
        ["git", "rev-list", "--count", f"{start_hash}..HEAD"], check=False
    )
    num_commits = int(git_output[0]) if git_output[1] == 0 else 1
    consider_squashing = num_commits != 1
    if run_git_command(["git", "rebase", parent], check=False)[1] == 0:
        print("  Success!")
        return True
    if not consider_squashing:
        print("  Rebase failed.")
        return False
    print(
        f"  Failed! Attempting to squash {format_branch_name(branch)} ... ",
        end="",
        flush=True,
    )
    run_git_command(["git", "rebase", "--abort"], check=False)
    squash_branch = f"{branch}_squash_attempt"
    run_git_command(["git", "checkout", "-b", squash_branch])
    if run_git_command(["git", "squash"], check=False)[1] == 0:
        if run_git_command(["git", "rebase", parent], check=False)[1] == 0:
            run_git_command(["git", "switch", branch])
            run_git_command(["git", "reset", "--hard", squash_branch])
            run_git_command(["git", "branch", "-D", squash_branch])
            return True
    print("  Failed!")
    run_git_command(["git", "rebase", "--abort"], check=False)
    run_git_command(["git", "switch", branch])
    run_git_command(["git", "branch", "-D", squash_branch])
    run_git_command(["git", "rebase", parent], check=False)
    return False


def remove_empty_branches(sorted_branches: typing.List[typing.Tuple[str, str]]) -> None:
    """Remove empty branches in reverse topological order."""
    # Reverse to process children before parents
    for branch, parent in reversed(sorted_branches):
        if branch not in ("master", "main"):
            branch_tree = get_tree(branch)
            if bool(branch_tree) and branch_tree == get_tree(parent):
                run_git_command(["git", "branch", "-d", branch])
                print(f"- {format_branch_name(branch)}: Deleted")


def main() -> int:
    """Main entry point."""
    if len(sys.argv) > 1:
        print(f"Unexpected argument: {sys.argv[1]}", file=sys.stderr)
        return 1
    output, rc = run_git_command(["git", "rev-parse", "--show-toplevel"], check=False)
    if rc != 0:
        print("Not in a git repository", file=sys.stderr)
        return 1
    os.chdir(output)
    if os.path.isdir(".git/rebase-merge") or os.path.isdir(".git/rebase-apply"):
        print(
            "Rebase in progress. Please complete the rebase before running git rb again.",
            file=sys.stderr,
        )
        return 1
    branch_tree = get_branch_tree()
    if not branch_tree:
        print("No branches with upstreams found.")
        return 0
    run_git_command(["git", "fetch", "--all", "-q"])
    merge_bases = {}
    for branch, parent in branch_tree.items():
        mb_output, mb_rc = run_git_command(
            ["git", "merge-base", branch, parent], check=False
        )
        merge_bases[branch] = (
            mb_output
            if mb_rc == 0
            else run_git_command(["git", "rev-parse", parent])[0]
        )
    sorted_branches = topo_iter(branch_tree)
    unrebased_branches = []
    retcode = 0
    for branch, parent in sorted_branches:
        if not rebase_branch(branch, parent, merge_bases[branch]):
            retcode = 1
            unrebased_branches.append(branch)
    if unrebased_branches:
        print()
        print("The following branches could not be cleanly rebased:")
        for branch in unrebased_branches:
            print(f"  {format_branch_name(branch)}")
    if retcode == 0:
        remove_empty_branches(sorted_branches)
        run_git_command(["git", "gc", "--auto"])
    return retcode


if __name__ == "__main__":
    sys.exit(main())
