#!/usr/bin/env python3
"""git squash: Squash all commits on the current branch into a single commit"""

import os
import subprocess
import sys
import traceback
import typing


def run_git_command(
    cmd: typing.List[str], check: bool = True
) -> typing.Tuple[str, int]:
    """Run a git command and return output and return code."""
    result = subprocess.run(cmd, capture_output=True, text=True, check=check)
    return result.stdout.strip(), result.returncode


def get_ancestor() -> typing.Optional[str]:
    """Get the ancestor (merge-base) between HEAD and its upstream."""
    _, rc = run_git_command(["git", "rev-parse", "--abbrev-ref", "@{u}"], check=False)
    if rc != 0:
        return None
    ancestor, rc = run_git_command(["git", "merge-base", "HEAD", "@{u}"], check=False)
    return None if rc != 0 else ancestor


def main() -> int:
    """Main entry point."""
    try:
        if len(sys.argv) > 1:
            print(f"Unexpected argument: {sys.argv[1]}", file=sys.stderr)
            return 1
        output, rc = run_git_command(
            ["git", "rev-parse", "--show-toplevel"], check=False
        )
        if rc != 0:
            print("Not in a git repository", file=sys.stderr)
            return 1
        os.chdir(output)
        if os.path.isdir(".git/rebase-merge") or os.path.isdir(".git/rebase-apply"):
            print(
                "Rebase in progress. Please complete the rebase before running git squash.",
                file=sys.stderr,
            )
            return 1
        branch, rc = run_git_command(
            ["git", "rev-parse", "--abbrev-ref", "HEAD"], check=False
        )
        if rc != 0 or branch == "HEAD":
            print("Not on a branch (detached HEAD state)", file=sys.stderr)
            return 1
        ancestor = get_ancestor()
        if not ancestor:
            print(
                f"No upstream branch configured for '{branch}'.\n"
                f"Set an upstream branch with: git branch --set-upstream-to=<upstream>",
                file=sys.stderr,
            )
            return 1
        commits_count, _ = run_git_command(
            ["git", "rev-list", "--count", f"{ancestor}..HEAD"]
        )
        if commits_count in ("0", "1"):
            return 0
        old_log, _ = run_git_command(
            ["git", "log", "--pretty=format:%B%x00", f"{ancestor}..HEAD"]
        )
        # Filter out commit messages that only contain "." or "," characters
        new_log = "\n\n".join(
            msg.rstrip()
            for msg in old_log.split("\x00")
            if msg and not all(c in ".,\n\r\t " for c in msg)
        ) or "Squashed commits"
        # print(f"Squashing {commits_count} commits on branch '{branch}'...")
        run_git_command(["git", "reset", "--soft", ancestor])
        run_git_command(["git", "commit", "-m", new_log])
        return 0
    except subprocess.CalledProcessError as e:
        # Find the frame that called run_git_command
        tb = traceback.extract_tb(e.__traceback__)
        frame = None
        for i, f in enumerate(tb):
            if f.name == "run_git_command" and i > 0:
                frame = tb[i - 1]
                break
        if frame:
            print(f"Error in {frame.name}() at line {frame.lineno}:", file=sys.stderr)
        print(f"Command failed: {' '.join(e.cmd)}", file=sys.stderr)
        if e.stdout:
            print(f"stdout: {e.stdout}", file=sys.stderr)
        if e.stderr:
            print(f"stderr: {e.stderr}", file=sys.stderr)
        return e.returncode


if __name__ == "__main__":
    sys.exit(main())
